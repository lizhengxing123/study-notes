<!--
 * @Descripttion: 
 * @Author: lizhengxing
 * @Date: 2022-10-18 19:37:03
 * @LastEditTime: 2022-10-18 21:31:58
-->

## 状态变量在存储中的布局

合约的状态变量以一种紧凑的方式存储在区块链存储中，以这样的方式，有时多个值会使用同一个存储槽。除了动态大小的数组和映射外，数据的存储是从位置`0`开始连续放置在存储中。对于每个变量，根据其类型确定字节大小。

存储大小少于32字节的多个变量会被打包到同一个存储槽中，规则如下：

- 存储槽的第一项会以低位对齐的方式进行存储
- 值类型仅使用存储他们所需的字节
- 如果存储槽的剩余空间不足以存储一个值类型，那么它会被存储进下一个存储槽
- 结构体和数组总是会开启新的存储槽，结构体和数组中的元素，会按规则进行紧密打包
- 结构体和数组之后的数据也会开启新的存储槽

对于使用继承的合约，状态变量的排序由C3线性化合约顺序（从最基类到最派生类）确定。如果上述规则成立，那么来自不同合约的状态变量会共享一个存储槽。

结构体和数组中的成员变量会存储到一起，就像它们单独声明时一样

> 在使用小于32字节的变量时，花费的gas可能高于32字节的变量。这是因为EVM每次操作32字节，如果小于32字节，EVM必须执行额外的操作使其大小缩减到所需大小。
> 把多个元素打包到同一个存储槽的好处是可以合并多次读写为单个操作，坏处就是：如果不是同一时间读或写一个槽中的值，那么当一个值被写入时，必须先读取这个槽，然后将其与新值合并，在写入。（避免破坏同一个槽中的其他数据）

**为了EVM的优化，请确保存储中的变量和`struct`成员的书写顺序允许它们被紧密打包。例如应该按照`uint128``uint128``uint256`顺序来声明，而不是`uint128``uint256``uint128`，前者占了两个存储槽，后者占了3个**

#### 映射和动态数组

由于映射和动态数组的不可预知大小，不能在状态变量之间存储它们，他们自身仅占用32字节，他们所包含的元素的存储的起始位置，则是通过`keccak256`哈希计算来确定。

假设映射和动态数组根据上述规则最终可确定某个位置`p`。对于动态数组，此存储槽会存储数组元素的数量（字节数组和字符串除外）。对于映射，该存储槽未被使用，为空，但它仍是需要的。他们的内容在不同位置上。

数组的元素会从`keccak256(p)`开始，他的布局与静态大小的数组相同，一个元素挨着一个元素，有可能共享存储槽。动态数组的数组会递归的使用这个规则。

##### bytes和string

`bytes`和`string`的编码是一样的。一般来说，编码和`bytes1[]`类似，即有一个存储槽存放数组本身，同时还有一个数据区，数据区位置使用槽的`keccak256`计算。
然而，对于短于32字节的数组，数组元素和长度在同一个存储槽中。

具体来说：如果数据长度小于等于31字节，则元素存储在高位字节（左对齐），最低位字节存储值`length * 2`，如果数据长度大于等于32字节，则在主存储槽`p`存储`length * 2 + 1`，数据照常存储在`leccak256(p)`位置上。设置了最低位就是短数组，没设置就是长数组。

#### JSON输出

合约的存储布局可以通过`JSON`输出，输出的`JSON`对象包括`storage`和`types`两个字段。

`storage`是一个数组，它的每个元素如下：

```solidity
{
    // 状态变量声明的ast节点id
    "astId": 2,
    // 合约名称，包括其路径作为前缀
    "contract": "fileA:A",
    // 变量名称
    "label": "x",
    // 根据编码在存储槽内以字节为单位的偏移量
    "offset": 0,
    // 状态变量所在或所开始的存储槽。这个数字可能非常大，它被表示为一个字符串
    "slot": 0,
    // 是一个标识符，作为变量类型信息的关键
    "type": "t_uint256"
}
```

上面是合约为：

```solidity
// fileA.sol
contract A {
    uint256 x;
}
```

给定的`type`，`t_uint256`代表`types`中的一个元素，其形式为

```solidity
{
    // 数据在存储中如何编码
    // inplace：数据在存储中连续排列
    // mapping：keccak256基于哈希的方法
    // dynamic_array：keccak256基于哈希的方法
    // bytes：单槽或keccak256基于哈希的方法
    "encoding": "inplace",
    // 规范的类型名称
    "label": "uint256",
    // 使用的字节数，十进制
    // 如果大于32，意味着使用了一个以上的槽位
    "numberOfBytes": 32
}
```
